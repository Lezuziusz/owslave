#!/usr/bin/python3

"""
This program is part of MoaT.
Its job is simply to extract values from a YAML-formatted config file.
"""

from Cfg import Cfg
import sys
import os
import re

### copied from port.h
PO_OFF=0
PO_ON=1
PO_Z=2
PO_PULLUP=3
PFLG_ALERT=  (1<<2)
PFLG_ALT  =  (1<<3)
PFLG_ALT2 =  (1<<4)

xstr = re.compile("^x([0-9a-fA-F]{2}){1,}$")

def main(f,*kk):
    s = Cfg(f)
    if kk:
        mode = ""
        for k in kk:
            if mode == "":
                if k[0] == '.':
                    if k == '.devs':
                        print(" ".join(sorted(k for k in s.subtree("devices") if not k.startswith('_'))))
                    else:
                        mode = k[1:]
                else:
                    did=[]
                    ks = k.split('.')
                    res = s.subtree(*ks)
                    if isinstance(res,dict):
                        print(" ".join("{}={}".format(a,v) for a,v in s.keyval(*ks)))
                    elif isinstance(res,(list,tuple)):
                        print(" ".join(str(x) for x in res))
                    elif xstr.match(res):
                        print(res[1:])
                    else:
                        try:
                            f = float(res)
                        except Exception:
                            print(res)
                        else:
                            g = int(f)
                            if float(g) == f:
                                print(g)
                            else:
                                print(f)
            elif mode == "hdr":
                with open("device/"+k+"/_port.h","w") as f:
                    print("""\
/*
 * This file is auto-generated. It contains the list of input/output ports for
 * the device "{}".
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k), file=f)
                    for i in range(1, int(s.subtree('devices',k,'types','port'))+1):
                        v = s.subtree('devices',k,'port',str(i))
                        flg=0
                        p=0
                        assert len(v)>=2 and len(v) <=6
                        for vv in v:
                            if vv >= 'A' and vv <= 'Z':
                                assert not p
                                p |= (ord(vv)-ord("A"))<<3
                            elif vv >= '0' and vv <= '7':
                                assert not (p&0x7)
                                p |= ord(vv)-ord("0")
                            elif vv == "^": flg|=PO_ON
                            elif vv == "_": flg|=PO_OFF
                            elif vv == "+": flg|=PO_PULLUP
                            elif vv == "~": flg|=PO_Z       ## high-impedance
                            elif vv == "/": flg|=PFLG_ALT   ## alt switch 1: low vs. pullup
                            elif vv == "!": flg|=PFLG_ALT2  ## alt switch 2: lw vs. Z
                            elif vv == "*": flg|=PFLG_ALERT ## participate in alerting
                            else: assert 0,vv
                        print('{'+"{},{}".format(p,flg)+'},',file=f)

                with open("device/"+k+"/dev_config.h","w") as f:
                    print("""\
#ifndef device_{}_config_h
#define device_{}_config_h

/*
 * This file is auto-generated. It contains a mix of global and local
 * definitions because I am lazy.
 *
 * Do not edit. Talk to 'moat.cfg' instead.
 */
    """.format(k,k), file=f)
                    i = 0
                    typecode = {}
                    for a in s.subtree('codes','types'):
                        typecode[a]=i
                        i += 1
                    i = 0x70
                    for a in s.subtree('codes','types_x70'):
                        typecode[a]=i
                        print("#define TC_{} {}".format(a.upper(),i), file=f)
                        i += 1

                    i = 1
                    print("typedef enum _ConfigID {", file=f)
                    for a in s.subtree('codes','blocks'):
                        typecode[a]=i
                        print("    CfgID_{} = {},".format(a,i), file=f)
                        i += 1
                    print("} ConfigID;", file=f)

                    for a,v in s.keyval('devices',k,'defs'):
                        try:
                            v = int(v)
                        except ValueError:
                            v = '"{}"'.format(v.replace('\\','\\\\').replace('"','\\"'))
                        else:
                            if not v:
                                continue

                        print("#define {} {}".format(a.upper(),v), file=f)

                    ow = s.subtree('devices',k,'defs','is_onewire')
                    if ow:
                        print("#define HAVE_ONEWIRE 1", file=f)

                    max_t = -1
                    for a,v in s.keyval('devices',k,'types'):
                        v = int(v)
                        print("#define TC_{} {}".format(a.upper(),typecode[a]), file=f)
                        if v > 0:
                            print("#define N_{} {}".format(a.upper(),v), file=f)

                            if max_t < typecode[a]:
                                max_t = typecode[a]
                    print("""\
#define MAX_TC {}

#endif /* device_{}_config_h */
    """.format(max_t,k,k), file=f)

            elif mode == "type":
                print(" ".join("{} {}".format(a,v) for a,v in s.keyval('devices',k,'types')))
            elif mode == "cdefs":
                types = dict((a,int(v)) for a,v in s.keyval('devices',k,'types') if int(v) > 0)
                maxtype = max(())
                print(" ".join("-D{}=\"{}\"".format(a.upper(),str(v).replace('"','\"')) for a,v in s.keyval('devices',k,'defs')) + " " + " ".join("-DN_{}={}".format(a.upper(),v) for a,v in s.keyval('devices',k,'types') if int(v) > 0))
            elif mode == "cfiles":
                files = ['dev_data.c','main.c','jmp.S']
                if s.subtree('devices',k,'defs','have_uart'):
                    files.append('uart.c')
                ow = s.subtree('devices',k,'defs','is_onewire')
                if not ow: pass
                elif ow in ('moat','ds2423','ds2408'):
                    files.append(ow+'.c')
                    files.append('onewire.c')
                else:
                    print("Unknown onewire mode:",ow, file=sys.stderr)
                    sys.exit(2)
                if not s.subtree('devices',k,'defs','use_eeprom'):
                    files.append('config.o')
                for f in s.subtree('devices',k,'code'):
                    files.append(f+'.c')
                for f in s.subtree('devices',k,'types'):
                    if f[0] == '_': continue
                    files.append('moat_'+f+'.c')
                    if os.path.exists(f+'.c'):
                        files.append(f+'.c')

                print(" ".join(files))
            else:
                print("Unknown mode:",mode, file=sys.stderr)
                sys.exit(2)
    else:
        import pprint
        pprint.pprint(s.data)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: {} file [type] [keyâ€¦]".format(sys.argv[0]), file=sys.stderr)
        sys.exit(2)
    main(*sys.argv[1:])
